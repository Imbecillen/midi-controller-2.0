// This project is based on the Teensy Monster 1.0: https://github.com/FuzzyWobble/TeensyMonster
// License: http://opensource.org/licenses/MIT
// Edit: Imbecillen / Sebastian Galo 2019
// GitHub for the project: https://github.com/Imbecillen/slowtech_midi_controller


#include <SPI.h>  // SPI library
#include <Wire.h> // I2C library
#include <Adafruit_GFX.h> // Display graphics library
#include <Adafruit_SSD1306.h> // Display library
#include <BitBool.h> //?

#define  OLED_RESET 4
Adafruit_SSD1306 display(OLED_RESET);



//MIDI CHANNEL_____________________________________________
int channelNumber = 1; 



//POTENTIOMETER THRESHOLD_______________________________
//jitter smoothing
int analogThreshold = 4;



//VAL+PIN TO DISPLAY__________________________________
//for displaying potentiometer values
int global_val, global_pin;



//BUTTON DEBOUNCE TIME___________________________________
//150 millisecond originally
uint32_t pbBounce = 150; 



//ANALOG MULTIPLEXER 1 READING, FOR POTENTIOMETERS________________
//'1' for multiplexer I/O you want to send signal, else enter '0'
//IC pin number are written below
int toReadAnalogMux1[16] = {
  1, 1, 1, 1, //0-3
  1, 1, 1, 1, //4-7
  1, 1, 1, 1, //8-11
  1, 1, 1, 1 //12-15
};



//DIGITAL MULTIPLEXER 1 READING, FOR PUSHBUTTONS______________
//'1' for multiplexer I/O you want to send signal, else enter '0'
//IC pin number are written below
int toReadDigitalMux1[16] = {
  1, 1, 1, 1, //0-3
  1, 1, 1, 1, //4-7
  1, 1, 1, 1, //8-11
  1, 1, 1, 1 //12-15
};



//PUSHBUTTON MODE______________________________________
//'1' - standard mode, when pushbutton is engaged note is turned on, when pushbutton is released, note is turned off
//'2' - on mode, note is only turned on with each click
//'3' - off mode, note is only turned off with each click
//'4' - toggle mode, note is switched between on and off with each click
//IC pin number are written below
int pushbuttonMode[16] = {
  2, 2, 2, 2, //0-3
  2, 2, 2, 2, //4-7
  2, 2, 2, 2, //8-11
  2, 2, 2, 2 //12-15 (NOTE: comma after last row/number for shift function to continue down under)
};



//PUSHBUTTON LEDS__________________________________________
//IC pin number are written below
//'1' for shift register pin you want to send signal to, else enter '0'
int toDisplayLed[16] = {
  1, 1, 1, 1, //0-3
  1, 1, 1, 1, //4-7
  1, 1, 1, 1, //8-11
  1, 1, 1, 1 //12-15
};



//SHIFT REGISTERS FOR PUSHBUTTON LEDS__________________________
//set number of shift registers and number of bytes in buttonState + toggleState array
const int numOfBytes = 2; 



// TEENSY LED________________________________________
//blinks when alive!
//pin 13 has the LED on Teensy LC and 3.0
//ledState used to set the LED
const int led = 13;  
int ledState = LOW;             
//Generally, you should use "unsigned long" for variables that hold time,
//the value will quickly become too large for an int to store.
//will store last time LED was updated
unsigned long previousMillis = 0;
//constants won't change
//interval at which to blink (milliseconds)
const long interval = 800;



//MULTIPLEXER READING SIGNAL, INPUT PINS________________________________
//reading pins for signal from multiplexers
int analogSignalMux1 = 15; 
int digitalSignalMux1 = 0; 



//MULTIPLEXER CONTROL SIGNAL, OUTPUT PINS_______________________
int s0 = 1; //control pin A
int s1 = 2; //control pin B
int s2 = 3; //control pin C
int s3 = 4; //control pin D



//MULTIPLEXER INHIBITOR, OUTPUT PINS_____________________________
//is this right? Can the muxes share inhibitor pin input or do they have to be separate?
//reading pins for inhibitor from multiplexers
int inhibitAnalogMux1 = 5;
int inhibitDigitalMux1 = 9;



//SHIFT REGISTER FOR PUSHBUTTON LEDS, OUTPUT PINS_____________________
int latchPin = 10; // ST_CP, SS (Storage register clock pin)
int clockPin = 14; // SH_CP, SCK (Shift register clock pin) Set to alternative pin 14 instead of 13!!
int dataPin = 11;  // DS, MOSI (data out from Teensy, into 595)



//ANALOG IN MULTIPLEXER 1________________________________
int analogInsPrev1[16]; //array to hold previously read analog values - set all to zero for now
int tempAnalogInMux1 = 0; //array to hold previously read analog values
int tempAnalogInMap1 = 0;
int analogControlPin1[] = {s0, s1, s2, s3}; //set contol pins in array
//control array
int analogMuxChannel1[16][4] = {{0, 0, 0, 0}, {1, 0, 0, 0}, {0, 1, 0, 0}, {1, 1, 0, 0}, {0, 0, 1, 0},
  {1, 0, 1, 0}, {0, 1, 1, 0}, {1, 1, 1, 0}, {0, 0, 0, 1}, {1, 0, 0, 1}, {0, 1, 0, 1}, {1, 1, 0, 1},
  {0, 0, 1, 1}, {1, 0, 1, 1}, {0, 1, 1, 1}, {1, 1, 1, 1}
};
//function to read mux
int analogReadMux1(int analogChannel1) {
  //loop through the four control pins
  for (int i = 0; i < 4; i ++) {
    //turn on/off the appropriate control pins according to what channel we are trying to read
    digitalWrite(analogControlPin1[i], analogMuxChannel1[analogChannel1][i]);
  }
  //read the value of the pin
  int analogVal1 = analogRead(analogSignalMux1);
  //return the value
  return analogVal1;
}


//DIGITAL IN MULTIPLEXER 1________________________________
unsigned long timeHit[16];
boolean buttonState[numOfBytes * 8]; //array with stored state from mode 1,2,3
boolean toggleState[numOfBytes * 8]; //array with stored state from mode 4
boolean callbackState[numOfBytes * 8]; //array with stored state from PC

boolean tempDigitalRead1 = 0;//array to hold previously read values
int digitalControlPin1[] = {s0, s1, s2, s3}; //set contol pins in array
//control array
int digitalMuxChannel1[16][4] = {{0, 0, 0, 0}, {1, 0, 0, 0}, {0, 1, 0, 0}, {1, 1, 0, 0}, {0, 0, 1, 0},
  {1, 0, 1, 0}, {0, 1, 1, 0}, {1, 1, 1, 0}, {0, 0, 0, 1}, {1, 0, 0, 1}, {0, 1, 0, 1}, {1, 1, 0, 1},
  {0, 0, 1, 1}, {1, 0, 1, 1}, {0, 1, 1, 1}, {1, 1, 1, 1}
};
//function to read mux
int digitalReadMux1(int digitalChannel1) {
  //loop through the four control pins
  for (int i = 0; i < 4; i ++) {
    delayMicroseconds (20);
    //turn on/off the appropriate control pins according to what channel we are trying to read
    digitalWrite(digitalControlPin1[i], digitalMuxChannel1[digitalChannel1][i]);
  }
  //read the value of the pin
  int digitalVal1 = digitalRead(digitalSignalMux1);
  //return the value
  return digitalVal1;
}



void setup() {

  //SERIAL MONITOR________________________________________
  //Baud rate, what to use?
  Serial.begin(115200);



  //AREF_______________________________________________
  //voltage reference for analog input, MUST BE BEFORE analogRead in the loop!
  analogReference(EXTERNAL);



  //SHIFT REGISTER BUTTONS, OUTPUT PINS________________________________
  SPI.setMOSI(11);  // DS, MOSI (data out from Teensy, into 595)
  SPI.setSCK(14);   // SH_CP, SCK (Shift register clock pin) Set to alternative pin 14, instead of 13 which TEENSY LED uses
  SPI.begin();      



  //DISPLAY LAUNCH_____________________________________
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(WHITE);



  //MULTIPLEXER READING SIGNAL, INPUT PINS________________________________
  //reading pins for signal from multiplexers
  pinMode(analogSignalMux1, INPUT);
  pinMode(digitalSignalMux1, INPUT); //INPUT_PULLUP used before external pullup resistors was installed



  //MULTIPLEXER CONTROL SIGNAL, OUTPUT PINS_______________________
  pinMode(s0, OUTPUT);
  pinMode(s1, OUTPUT);
  pinMode(s2, OUTPUT);
  pinMode(s3, OUTPUT);

  //turn all control pins off (for now)
  digitalWrite(s0, LOW);
  digitalWrite(s1, LOW);
  digitalWrite(s2, LOW);
  digitalWrite(s3, LOW);



   //MULTIPLEXER INHIBITOR, OUTPUT PINS_____________________________
  pinMode(inhibitAnalogMux1, OUTPUT);
  pinMode(inhibitDigitalMux1, OUTPUT);

  //set inhibit pin to output and turn low to keep them alive, if else set to HIGH (?)
  digitalWrite(inhibitAnalogMux1, LOW);
  digitalWrite(inhibitDigitalMux1, LOW);



  //SHIFT REGISTER FOR PUSHBUTTON LEDS, OUTPUT PINS_____________________
  //set shift register pins to output
  pinMode(latchPin, OUTPUT);
  pinMode(clockPin, OUTPUT);
  pinMode(dataPin, OUTPUT);


  //SET HANDLES FOR VOIDS, readUSB.MIDI
  usbMIDI.setHandleNoteOn(noteOn);
  usbMIDI.setHandleNoteOff(noteOff);



  // TEENSY LED________________________________________
  // initialize the digital pin as an output for Teensy LED
  pinMode(led, OUTPUT);


} // SETUP END





void loop() {


  // TEENSY LED BLINKS WHEN PROCESSING SIGNAL
  // check to see if it's time to blink the LED; that is, if the difference
  // between the current time and last time you blinked the LED is bigger than
  // the interval at which you want to blink the LED.
  unsigned long currentMillis = millis();

  if (currentMillis - previousMillis >= interval) {
    // save the last time you blinked the LED
    previousMillis = currentMillis;

    // if the LED is off turn it on and vice-versa:
    if (ledState == LOW) {
      ledState = HIGH;
    } else {
      ledState = LOW;
    }

    // set the LED with the ledState of the variable:
    digitalWrite(led, ledState);
  }



  //READ MIDI CALLBACK_______________________________________________
  usbMIDI.read(); 



  //ANALOG MULTIPLEXER 1_______________________________________________
  for (int i = 0; i < 16; i++) { //loop through 16 mux channels
    if (toReadAnalogMux1[i] == 1) { //we read this mux channel analog input
      tempAnalogInMux1 = analogReadMux1(i); //ready valued using readMux function
      if (abs(analogInsPrev1[i] - tempAnalogInMux1) > analogThreshold) { //ensure value changed more than our threshold
        tempAnalogInMap1 = map(tempAnalogInMux1, 0, 1023, 0, 127); //remap value between 0 and 127
        midiSend('a', tempAnalogInMap1, i); //send message
        analogInsPrev1[i] = tempAnalogInMux1; //update current value
      }
    }
  }



  //DIGITAL MULTIPLEXER 1_______________________________________________
  for (int i = 0; i < 16; i++) { //loop through 16 mux channels
    if (toReadDigitalMux1[i] == 1) { //we read the choosen mux channel input
      tempDigitalRead1 = digitalReadMux1(i);
      if (pushbuttonMode[i] == 1 && tempDigitalRead1 != buttonState[i]) { //___NORMAL MODE (1)
        delay(20); //just a delay for noise to ensure push button was actually hit
        if (digitalReadMux1(i) == tempDigitalRead1) { //check if pushbutton is still the same
          if (tempDigitalRead1 == LOW) { //button pressed, turn note on
            midiSend('p', 1, i); //call note on/off function
          } else { //button released
            midiSend('p', 0, i);
          }
          buttonState[i] = tempDigitalRead1; //update the state (on or off)
        }
      } else { //___ALL OTHER MODES (2,3,4)
        if (digitalReadMux1(i) == LOW && (millis() - timeHit[i]) > pbBounce) { //check bounce time
          if (pushbuttonMode[i] == 2) { //mode 2 - only note on
            midiSend('p', 1, i);
          } else if (pushbuttonMode[i] == 3) { //mode 3 - only note off
            midiSend('p', 0, i);
          } else { //mode 4 - toggle
            if (buttonState[i] == 1) { //on->off
              midiSend('p', 0, i);
              buttonState[i] = 0;
            } else { //off->on
              midiSend('p', 1, i);
              buttonState[i] = 1;
            }
          }
          timeHit[i] = millis();
        }
      }
    }
  }




  //DIGITAL OUT SHIFT REGISTER FOR LEDS_______________________
    for (byte i = numOfBytes; i > 0; i--) { //get bytes from array
      for (byte j = 8; j > 0; j--) {    //send information
        if (pushbuttonMode[i] == 2) {
          digitalWrite(dataPin, buttonState[((i - 1) * 8) + (j - 1)]);      // mode 1
          digitalWrite(clockPin, HIGH);  // clock the output into the 595
          digitalWrite(clockPin, LOW);

        } else {
          digitalWrite(dataPin, toggleState[((i - 1) * 8) + (j - 1)]);      // mode 4
          digitalWrite(clockPin, HIGH);  // clock the output into the 595
          digitalWrite(clockPin, LOW);
        }
        digitalWrite(latchPin, 1);
        digitalWrite(latchPin, 0);
      }
    }
  



  //DISPLAY____________________________________
    {
      //Display text
      display.setCursor(0, 0);
      display.print("CC number ~ "); // Change to CC number?
      display.println(global_pin);  //Put CCnumber here

      display.setCursor(0, 12);
      display.print("says hi at");

      display.setCursor(0, 24);
      display.print("MIDI channel ~ ");
      display.println(channelNumber); // Put midichannel here

      display.setCursor(0, 36);
      display.print("n tickling");
      display.setCursor(0, 48);
      display.print("VALUE number ~");
      display.setCursor(91, 48);
      display.println(global_val); // to vary 0 to end result, ie 1024/?  //Put CC value here

      //Display parameter bar
      display.fillRect(0, 63, global_val, 1, 1); // 2=V from left; 61=H from top; val/8= lenght of bar ie,
      //val/16 is half screen with full value; 3= thickness of slide bar; 1= ? colour or brightness
      display.display();
      display.clearDisplay();  // Clear display must be used to clear text etc
    }


  }    // LOOP END
  
  
  


  //Function to send MIDI
  //http://www.pjrc.com/teensy/td_midi.html
  
  void midiSend(char type, int val, int pin) {
    String clickState;
    switch (type) {

      case 'p': //--------------- PUSHBUTTON
        if (val == 1) {
          usbMIDI.sendNoteOn(pin, 127, channelNumber); //!!!
        } else {
          usbMIDI.sendNoteOff(pin, 127, channelNumber); //!!!
        }
        break;

      case 'a': //--------------- POTENTIOMETERS
        usbMIDI.sendControlChange(pin, val, channelNumber); //!!!
        global_val = val;
        global_pin = pin;
        break;
        delay(500);

    }
  } 



  void noteOn(byte channel, byte note, byte velocity) {
    
        digitalWrite(latchPin, LOW);
        shiftOut(dataPin, clockPin, MSBFIRST, note);
        digitalWrite(latchPin, HIGH);  //Write 'pitch' to 74HC595. Standard fare
  }

  void noteOff(byte channel, byte note, byte velocity) {
        digitalWrite(latchPin, LOW);
        shiftOut(dataPin, clockPin, MSBFIRST, 0x00);
        digitalWrite(latchPin, HIGH);
  }



#include "usb_names.h"

// Edit these lines to create your own name.  The length must
// match the number of characters in your custom name.

#define MIDI_NAME   {'S','L','O','W','T','E','C','H'}
#define MIDI_NAME_LEN  8

// Do not change this part.  This exact format is required by USB.

struct usb_string_descriptor_struct usb_string_product_name = {
        2 + MIDI_NAME_LEN * 2,
        3,
        MIDI_NAME
};
